1.Hash table 哈希表,也叫散列表，是根据关键码值直接进行访问的数据结构，通过关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做哈希表（或散列表）。
哈希表基础实现：哈希函数（例如hash code）
哈希碰撞：发生碰撞就在碰撞的位置生成一个链表把数值累加串联起来
Hash table java 10 去查看api
正常情况下访问是o(1)的时间复杂度，特殊情况下哈希函数选的不好，或者size太小产	生很多链表就是O（n）的时间复杂度
Map key-value

Set 不重复元素集合 （接口）
2.树，二叉树，二叉搜索树
树和图最大的差别就是有没有环
LinkedList 是特殊化的Tree    Tree是特殊化的Graph

Public class TreeNode {
Public int val;
Public TreeNode left,right;
Public TreeNode (int val) {
This.val = val;
This.left=null;
This.right=null;
}
}
前序：根左右
	中序：左根右
后续；左右跟
二叉搜索树：二叉排序树，有序二叉树，排序二叉树，空树。左子树的所有节点和右子	树的所有节点的值均小于打的根节点的值。
	中序遍历是升序遍历
查询和操作都是O（logn）
3.堆和二叉堆
堆Heap：可以迅速找到一堆数中的最大或者最小的数据结构。
将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆货小根堆。常见的	堆有二叉堆，斐波那契堆等。
二叉堆：通过完全二叉树来实现（注意不是二叉搜索树）,性质一完全二叉树，性质二	最上面的根节点肯定是最大值
二叉堆实现细节
1.一般通过数组来实现
2.假设第一个元素在数组的索引为0的话，父节点和子节点的位置关系
(01)索引为i的左孩子的索引是（2*i+1）；
(02)索引为i的左孩子的索引是（2*1+2）；
(03)索引为i的的父节点的索引是floor（（i-1）/2）；
插入操作 logn
1.先把值插入数组的尾部。
2.和父节点进行比较如果大于父节点就交换
删除操作 logn
1.将堆尾的元素替换到堆顶，数组长度减一
2.比较左右节点最大的交换。
注意二叉堆是堆（优先队列prioority_queue）的一种常见且简单的实现；并不是最优实	现
4. 图的实现和特效
Graph(V, E)
V - vertex:点
1.度-入度和出度
2.点与点之间：连动与否
E - edge:边
1.有向和无向（单行线）
2.权重
邻接矩阵和邻接表

